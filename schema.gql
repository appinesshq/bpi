directive @hasInverse(field: String!) on FIELD_DEFINITION
directive @dgraph(
  type: String
  pred: String
) on OBJECT | INTERFACE | FIELD_DEFINITION
directive @withSubscription on OBJECT | INTERFACE
directive @secret(field: String!, pred: String) on OBJECT | INTERFACE
directive @search(by: [DgraphIndex!]) on FIELD_DEFINITION
directive @auth(
  query: AuthRule
  add: AuthRule
  update: AuthRule
  delete: AuthRule
) on OBJECT
directive @custom(http: CustomHTTP, dql: String) on FIELD_DEFINITION
directive @remote on OBJECT | INTERFACE
directive @id on FIELD_DEFINITION
directive @cascade(fields: [String]) on FIELD
directive @lambda on FIELD_DEFINITION
input AddCountryInput {
  code: String!
  name: String!
  jurisdictions: [JurisdictionRef]
}

type AddCountryPayload {
  country(
    filter: CountryFilter
    order: CountryOrder
    first: Int
    offset: Int
  ): [Country]
  numUids: Int
}

input AddJurisdictionInput {
  code: String!
  name: String!
  country: CountryRef!
}

type AddJurisdictionPayload {
  jurisdiction(
    filter: JurisdictionFilter
    order: JurisdictionOrder
    first: Int
    offset: Int
  ): [Jurisdiction]
  numUids: Int
}

input AddUserInput {
  handle: String!
  email: String!
  password: String!
  contacts: [UserRef]
}

type AddUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  numUids: Int
}

input AuthRule {
  and: [AuthRule]
  or: [AuthRule]
  not: AuthRule
  rule: String
}

type Country {
  id: ID!
  code: String!
  name: String!
  jurisdictions(
    filter: JurisdictionFilter
    order: JurisdictionOrder
    first: Int
    offset: Int
  ): [Jurisdiction]
}

input CountryFilter {
  id: [ID!]
  has: CountryHasFilter
  and: CountryFilter
  or: CountryFilter
  not: CountryFilter
}

enum CountryHasFilter {
  code
  name
  jurisdictions
}

input CountryOrder {
  asc: CountryOrderable
  desc: CountryOrderable
  then: CountryOrder
}

enum CountryOrderable {
  code
  name
}

input CountryPatch {
  code: String
  name: String
  jurisdictions: [JurisdictionRef]
}

input CountryRef {
  id: ID
  code: String
  name: String
  jurisdictions: [JurisdictionRef]
}

input CustomHTTP {
  url: String!
  method: HTTPMethod!
  body: String
  graphql: String
  mode: Mode
  forwardHeaders: [String!]
  secretHeaders: [String!]
  introspectionHeaders: [String!]
  skipIntrospection: Boolean
}

scalar DateTime

input DateTimeFilter {
  eq: DateTime
  le: DateTime
  lt: DateTime
  ge: DateTime
  gt: DateTime
}

type DeleteCountryPayload {
  country(
    filter: CountryFilter
    order: CountryOrder
    first: Int
    offset: Int
  ): [Country]
  msg: String
  numUids: Int
}

type DeleteJurisdictionPayload {
  jurisdiction(
    filter: JurisdictionFilter
    order: JurisdictionOrder
    first: Int
    offset: Int
  ): [Jurisdiction]
  msg: String
  numUids: Int
}

type DeleteUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  msg: String
  numUids: Int
}

enum DgraphIndex {
  int
  int64
  float
  bool
  hash
  exact
  term
  fulltext
  trigram
  regexp
  year
  month
  day
  hour
  geo
}

input FloatFilter {
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
}

enum HTTPMethod {
  GET
  POST
  PUT
  PATCH
  DELETE
}

scalar Int64

input Int64Filter {
  eq: Int64
  le: Int64
  lt: Int64
  ge: Int64
  gt: Int64
}

input IntFilter {
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
}

type Jurisdiction {
  id: ID!
  code: String!
  name: String!
  country(filter: CountryFilter): Country!
}

input JurisdictionFilter {
  id: [ID!]
  has: JurisdictionHasFilter
  and: JurisdictionFilter
  or: JurisdictionFilter
  not: JurisdictionFilter
}

enum JurisdictionHasFilter {
  code
  name
  country
}

input JurisdictionOrder {
  asc: JurisdictionOrderable
  desc: JurisdictionOrderable
  then: JurisdictionOrder
}

enum JurisdictionOrderable {
  code
  name
}

input JurisdictionPatch {
  code: String
  name: String
  country: CountryRef
}

input JurisdictionRef {
  id: ID
  code: String
  name: String
  country: CountryRef
}

enum Mode {
  BATCH
  SINGLE
}

type Mutation {
  addUser(input: [AddUserInput!]!): AddUserPayload
  updateUser(input: UpdateUserInput!): UpdateUserPayload
  deleteUser(filter: UserFilter!): DeleteUserPayload
  addCountry(input: [AddCountryInput!]!): AddCountryPayload
  updateCountry(input: UpdateCountryInput!): UpdateCountryPayload
  deleteCountry(filter: CountryFilter!): DeleteCountryPayload
  addJurisdiction(input: [AddJurisdictionInput!]!): AddJurisdictionPayload
  updateJurisdiction(input: UpdateJurisdictionInput!): UpdateJurisdictionPayload
  deleteJurisdiction(filter: JurisdictionFilter!): DeleteJurisdictionPayload
}

input NearFilter {
  distance: Float!
  coordinate: PointRef!
}

type Point {
  longitude: Float!
  latitude: Float!
}

input PointGeoFilter {
  near: NearFilter!
}

input PointRef {
  longitude: Float!
  latitude: Float!
}

type Query {
  getUser(id: ID!): User
  queryUser(
    filter: UserFilter
    order: UserOrder
    first: Int
    offset: Int
  ): [User]
  getCountry(id: ID!): Country
  queryCountry(
    filter: CountryFilter
    order: CountryOrder
    first: Int
    offset: Int
  ): [Country]
  getJurisdiction(id: ID!): Jurisdiction
  queryJurisdiction(
    filter: JurisdictionFilter
    order: JurisdictionOrder
    first: Int
    offset: Int
  ): [Jurisdiction]
}

input StringExactFilter {
  eq: String
  in: [String]
  le: String
  lt: String
  ge: String
  gt: String
}

input StringFullTextFilter {
  alloftext: String
  anyoftext: String
}

input StringHashFilter {
  eq: String
  in: [String]
}

input StringRegExpFilter {
  regexp: String
}

input StringTermFilter {
  allofterms: String
  anyofterms: String
}

input UpdateCountryInput {
  filter: CountryFilter!
  set: CountryPatch
  remove: CountryPatch
}

type UpdateCountryPayload {
  country(
    filter: CountryFilter
    order: CountryOrder
    first: Int
    offset: Int
  ): [Country]
  numUids: Int
}

input UpdateJurisdictionInput {
  filter: JurisdictionFilter!
  set: JurisdictionPatch
  remove: JurisdictionPatch
}

type UpdateJurisdictionPayload {
  jurisdiction(
    filter: JurisdictionFilter
    order: JurisdictionOrder
    first: Int
    offset: Int
  ): [Jurisdiction]
  numUids: Int
}

input UpdateUserInput {
  filter: UserFilter!
  set: UserPatch
  remove: UserPatch
}

type UpdateUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  numUids: Int
}

type User {
  id: ID!
  handle: String!
  email: String!
  password: String!
  contacts(
    filter: UserFilter
    order: UserOrder
    first: Int
    offset: Int
  ): [User]
}

input UserFilter {
  id: [ID!]
  handle: StringExactFilter
  email: StringExactFilter
  has: UserHasFilter
  and: UserFilter
  or: UserFilter
  not: UserFilter
}

enum UserHasFilter {
  handle
  email
  password
  contacts
}

input UserOrder {
  asc: UserOrderable
  desc: UserOrderable
  then: UserOrder
}

enum UserOrderable {
  handle
  email
  password
}

input UserPatch {
  handle: String
  email: String
  password: String
  contacts: [UserRef]
}

input UserRef {
  id: ID
  handle: String
  email: String
  password: String
  contacts: [UserRef]
}

